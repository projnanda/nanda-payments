import { Router } from "express";
import { z } from "zod";
import { TransactionModel, IdemModel, NP_CURRENCY, NP_SCALE } from "../models/index.js";
import { createTransactionWithReputation } from "../services/transactionEngine.js";
import { initializeReputationService, generateTestVerifierKeys } from "../services/reputationManager.js";

export const reputationTransactions = Router();

// Enhanced transaction endpoint with reputation verification
reputationTransactions.post("/transactions/with-reputation", async (req, res) => {
  const schema = z.object({
    type: z.enum(["mint","burn","transfer","earn","spend","hold","capture","refund","reversal"]),
    sourceWalletId: z.string().nullable().optional(),
    destWalletId: z.string().nullable().optional(),
    amount: z.object({ 
      currency: z.string().default(NP_CURRENCY), 
      scale: z.number().default(NP_SCALE), 
      value: z.number().int().positive() 
    }),
    reasonCode: z.string(),
    idempotencyKey: z.string(),
    actor: z.object({ 
      type: z.enum(["agent","system"]).default("agent"), 
      did: z.string().optional(), 
      walletId: z.string().optional() 
    }).optional(),
    facts: z.object({
      ttlSec: z.number().optional(),
      from: z.object({ 
        did: z.string().optional(), 
        primaryFactsUrl: z.string().optional(), 
        vcStatusUrl: z.string().optional(), 
        factsDigest: z.string().optional(), 
        eventsWebhook: z.string().optional(), 
        endpointClass: z.enum(["static","adaptive","rotating"]).optional() 
      }).optional(),
      to: z.object({ 
        did: z.string().optional(), 
        primaryFactsUrl: z.string().optional(), 
        vcStatusUrl: z.string().optional(), 
        factsDigest: z.string().optional(), 
        eventsWebhook: z.string().optional(), 
        endpointClass: z.enum(["static","adaptive","rotating"]).optional() 
      }).optional()
    }).optional(),
    metadata: z.any().optional(),
    reputationHash: z.string().optional(),  // New field for reputation verification
    skipReputationCheck: z.boolean().default(false)  // Option to skip reputation check
  });

  try {
    const body = schema.parse(req.body);
    
    // Check for existing transaction
    const existing = await IdemModel.findOne({ key: body.idempotencyKey });
    if (existing) {
      const tx = await TransactionModel.findById(existing.txId);
      return res.status(200).json(tx);
    }

    // Create transaction with reputation verification
    const tx = await createTransactionWithReputation({
      type: body.type,
      sourceWalletId: body.sourceWalletId ?? null,
      destWalletId: body.destWalletId ?? null,
      amountValue: body.amount.value,
      reasonCode: body.reasonCode,
      actor: body.actor,
      idempotencyKey: body.idempotencyKey,
      facts: body.facts,
      metadata: body.metadata,
      reputationHash: body.reputationHash,
      skipReputationCheck: body.skipReputationCheck
    });

    res.status(201).json(tx);
  } catch (e: any) {
    let code = e?.httpCode || 400;
    let errorCode = "VALIDATION_ERROR";
    
    // Handle reputation-specific errors
    if (e?.reputationError) {
      code = 403;
      errorCode = "REPUTATION_VERIFICATION_FAILED";
    }
    
    res.status(code).json({ 
      error: { 
        code: errorCode, 
        message: e?.message ?? "Invalid request",
        reputationError: e?.reputationError || false
      } 
    });
  }
});

// Endpoint to initialize reputation service (for testing/setup)
reputationTransactions.post("/reputation/initialize", async (req, res) => {
  const schema = z.object({
    privateKey: z.string(),
    publicKey: z.string()
  });

  try {
    const body = schema.parse(req.body);
    initializeReputationService(body.privateKey, body.publicKey);
    res.json({ message: "Reputation service initialized successfully" });
  } catch (e: any) {
    res.status(400).json({ error: { code: "VALIDATION_ERROR", message: e?.message ?? "Invalid request" } });
  }
});

// Endpoint to generate test verifier keys
reputationTransactions.post("/reputation/generate-keys", async (req, res) => {
  try {
    const keys = generateTestVerifierKeys();
    res.json({
      message: "Test verifier keys generated",
      keys: {
        privateKey: keys.privateKey,
        publicKey: keys.publicKey
      }
    });
  } catch (e: any) {
    res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "Failed to generate keys" } });
  }
});

// Endpoint to get reputation requirements for different transaction types
reputationTransactions.get("/reputation/requirements", async (req, res) => {
  const { transactionType, amount } = req.query as any;
  
  if (!transactionType) {
    return res.status(400).json({ error: { code: "VALIDATION_ERROR", message: "transactionType is required" } });
  }

  const amountValue = amount ? parseInt(amount, 10) : 1000;

  // This would typically come from the reputation service, but we'll simulate it
  const requirements = {
    'transfer': amountValue > 10000 ? 70 : 50,
    'earn': 40,
    'spend': 60,
    'mint': 80,
    'burn': 30,
    'hold': 50,
    'capture': 65,
    'refund': 45,
    'reversal': 90
  };

  const minScore = requirements[transactionType as keyof typeof requirements] || 50;

  res.json({
    transactionType,
    amount: amountValue,
    minimumReputationScore: minScore,
    description: `Minimum reputation score of ${minScore} required for ${transactionType} transactions`
  });
});

// Get transaction with reputation information
reputationTransactions.get("/transactions/:txId/reputation", async (req, res) => {
  try {
    const tx = await TransactionModel.findById(req.params.txId);
    if (!tx) {
      return res.status(404).json({ error: { code: "NOT_FOUND", message: "Transaction not found" } });
    }

    const reputationInfo = {
      transactionId: tx._id,
      hasReputationHash: !!tx.links?.reputationHash,
      reputationHash: tx.links?.reputationHash,
      agentDid: tx.actor?.did,
      transactionType: tx.type,
      amount: tx.amount?.value,
      status: tx.status
    };

    res.json(reputationInfo);
  } catch (e: any) {
    res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "Failed to retrieve transaction reputation info" } });
  }
});

// Get agent reputation score by DID
reputationTransactions.get("/agents/:did/reputation", async (req, res) => {
  try {
    const { did } = req.params;
    
    if (!did) {
      return res.status(400).json({ error: { code: "VALIDATION_ERROR", message: "Agent DID is required" } });
    }

    // Import reputation service dynamically to avoid circular dependencies
    const { getReputationService, isReputationServiceReady } = await import('../services/reputationManager.js');
    const reputationService = getReputationService();
    const serviceReady = isReputationServiceReady();

    if (!reputationService || !serviceReady) {
      return res.status(503).json({ 
        error: { 
          code: "SERVICE_UNAVAILABLE", 
          message: "Reputation service not initialized. Please call /reputation/initialize first." 
        } 
      });
    }

    // For now, we'll return a mock reputation score since we don't have persistent storage
    // In a real implementation, this would fetch from a database or external reputation system
    const mockReputationScore = {
      agentDid: did,
      score: 75, // This would come from your reputation database
      timestamp: new Date().toISOString(),
      source: "nanda-reputation-system",
      lastUpdated: new Date().toISOString(),
      transactionCount: 42, // Number of transactions this agent has made
      reputationLevel: "good", // good, excellent, poor, etc.
      requirements: {
        transfer: { minScore: 50, eligible: true },
        earn: { minScore: 40, eligible: true },
        spend: { minScore: 60, eligible: true },
        mint: { minScore: 80, eligible: false },
        burn: { minScore: 30, eligible: true },
        hold: { minScore: 50, eligible: true },
        capture: { minScore: 65, eligible: true },
        refund: { minScore: 45, eligible: true },
        reversal: { minScore: 90, eligible: false }
      }
    };

    res.json({
      success: true,
      data: mockReputationScore
    });

  } catch (e: any) {
    console.error(`[REPUTATION ERROR] Failed to fetch reputation for ${req.params.did}:`, e.message);
    res.status(500).json({ 
      error: { 
        code: "INTERNAL_ERROR", 
        message: "Failed to retrieve agent reputation score" 
      } 
    });
  }
});

// Get agent reputation score with encrypted hash (for verification purposes)
reputationTransactions.post("/agents/:did/reputation/verify", async (req, res) => {
  try {
    const { did } = req.params;
    const { reputationHash } = req.body;
    
    if (!did) {
      return res.status(400).json({ error: { code: "VALIDATION_ERROR", message: "Agent DID is required" } });
    }

    if (!reputationHash) {
      return res.status(400).json({ error: { code: "VALIDATION_ERROR", message: "Reputation hash is required" } });
    }

    // Import reputation service dynamically to avoid circular dependencies
    const { getReputationService, isReputationServiceReady } = await import('../services/reputationManager.js');
    const reputationService = getReputationService();
    const serviceReady = isReputationServiceReady();

    if (!reputationService || !serviceReady) {
      return res.status(503).json({ 
        error: { 
          code: "SERVICE_UNAVAILABLE", 
          message: "Reputation service not initialized. Please call /reputation/initialize first." 
        } 
      });
    }

    // Verify the reputation hash
    const verificationResult = await reputationService.verifyTransactionReputation(
      { reputationHash },
      did,
      0 // We don't need a minimum score for verification, just validation
    );

    if (!verificationResult.isValid) {
      return res.status(403).json({
        error: {
          code: "REPUTATION_VERIFICATION_FAILED",
          message: verificationResult.error || "Invalid reputation hash"
        }
      });
    }

    res.json({
      success: true,
      data: {
        agentDid: did,
        reputationScore: verificationResult.reputationScore,
        isValid: true,
        verifiedAt: new Date().toISOString()
      }
    });

  } catch (e: any) {
    console.error(`[REPUTATION ERROR] Failed to verify reputation for ${req.params.did}:`, e.message);
    res.status(500).json({ 
      error: { 
        code: "INTERNAL_ERROR", 
        message: "Failed to verify agent reputation" 
      } 
    });
  }
});
